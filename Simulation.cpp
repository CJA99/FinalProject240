#ifndef __Simulation_CPP__
#define __Simulation_CPP__

#include "Simulation.h"
#include <random>
#include <fstream>
#include <iostream>

using namespace std;

/**
 * Typical use contructor which passes an input file to determine elements of the simulation
 * and a seed to generate random numbers
 *
 * @param file the input file which is read in the constructor
 * @param seed the seed which random numbers are generated by
 */
Simulation::Simulation(string file, int seed){
	this->seed = seed;
    ifstream infile;
    infile.open(file);

    if(!infile){
        cerr << "Error: could not open file: " << file << endl;
		exit(1);
	}

	int count{};
	string name;
	string value;

	// while loop that reads the input file and stores variables
	while (infile.good()){
		count++;
		infile >> name >> value;

		if(count == 1)
			simTime	 = stoi(value);
		else if(count == 2)
			sectionsBeforeIntersection = stoi(value);
		else if(count == 3)
			greenNS = stoi(value);
		else if(count == 4)
			yellowNS = stoi(value);
		else if(count == 5)
			greenEW = stoi(value);
		else if(count == 6)
			yellowEW = stoi(value);
		else if(count == 7)
			probNewVehicleN = stod(value);
		else if(count == 8)
			probNewVehicleS = stod(value);
		else if(count == 9)
			probNewVehicleE = stod(value);
		else if(count == 10)
			probNewVehicleW = stod(value);
		else if(count == 11)
			proportionCars = stod(value);
		else if(count == 12)
			proportionSUVs = stod(value);
		else if(count == 13)
			probRightCars = stod(value);
		else if(count == 14)
			probLeftCars = stod(value);
		else if(count == 15)
			probRightSUVs = stod(value);
		else if(count == 16)
			probLeftSUVs = stod(value);
		else if(count == 17)
			probRightTrucks = stod(value);
		else if(count == 18)
			probLeftTrucks = stod(value);
	}
	infile.close();
	proportionTrucks = 1 - proportionCars - proportionSUVs;
}

/**
 * Destructor deletes every vehicle in the system
 */
Simulation::~Simulation(){
	for (size_t i = 0; i < vehicleVector.size(); i++)
      delete vehicleVector[i];
	vehicleVector.clear();
}

/**
 *  Start and animate the simulation
 */
void Simulation::runSim(){
	char dummy;

	// Set up animator
	Animator anim(sectionsBeforeIntersection);

	// Create middleSections
    MiddleSection ms1;
    MiddleSection ms2;
    MiddleSection ms3;
    MiddleSection ms4;

	// Create trafficLights
	TrafficLight trafficLightNS(greenNS, yellowNS, greenEW + yellowEW, LightColor::green);
    TrafficLight trafficLightEW(greenEW, yellowEW, greenNS + yellowNS, LightColor::red);

	// Create 4 lanes
    Lane northbound(Direction::north, sectionsBeforeIntersection, &ms1, &ms2, &trafficLightNS);
    Lane westbound(Direction::west, sectionsBeforeIntersection, &ms2, &ms3, &trafficLightEW);
    Lane southbound(Direction::south, sectionsBeforeIntersection, &ms3, &ms4, &trafficLightNS);
    Lane eastbound(Direction::east, sectionsBeforeIntersection, &ms4, &ms1, &trafficLightEW);

	// Set up empty lanes
	anim.setVehiclesNorthbound(northbound.getLaneVector());
    anim.setVehiclesWestbound(westbound.getLaneVector());
    anim.setVehiclesSouthbound(southbound.getLaneVector());
    anim.setVehiclesEastbound(eastbound.getLaneVector());

	// Create random number generator
    std::mt19937 mt;
    std::uniform_real_distribution<double> rand_double(0,1);
    mt.seed(seed);

	// Simulation loop
	for (int i = 0; i <= simTime; i++){

		// Create vehicles on 4 lanes
		createVehicle(&northbound, probNewVehicleN, rand_double(mt), rand_double(mt), rand_double(mt));
		createVehicle(&westbound, probNewVehicleW, rand_double(mt), rand_double(mt), rand_double(mt));
		createVehicle(&southbound, probNewVehicleS, rand_double(mt), rand_double(mt), rand_double(mt));
		createVehicle(&eastbound, probNewVehicleE, rand_double(mt), rand_double(mt), rand_double(mt));

		// Set trafficLight color
		anim.setLightNorthSouth(trafficLightNS.getColor());
        anim.setLightEastWest(trafficLightEW.getColor());

		// Set up lanes with animator
		anim.setVehiclesNorthbound(northbound.getLaneVector());
        anim.setVehiclesWestbound(westbound.getLaneVector());
        anim.setVehiclesSouthbound(southbound.getLaneVector());
        anim.setVehiclesEastbound(eastbound.getLaneVector());

		// Draw timer
		anim.draw(i);

		// Wait for a button to be pressed
        std::cin.get(dummy);

		// Move traffic
		step();

		// Decrement time on trafficLights
		trafficLightNS.decrement();
        trafficLightEW.decrement();
	}
}

/**
 * Create a vehicle on a lane if there is place
 * @param lane pointer to the lane where the Vehicle will be spawned
 * @param laneProb the probability that a vehicle will spawn in a particular lane
 * @param createProb the probability that a vehicle will be created
 * @param vehicleProb the probability of the vehicle being a Car, SUV or Truck
 * @param turnProb the probability that the vehicle will turn right
 */
void Simulation::createVehicle(Lane *lane, double laneProb, double createProb,
	double vehicleProb, double turnProb){

	// If it is possible to create a vehicle and probability is correct
	if((lane->canCreate()) && (createProb <= laneProb)){
		Vehicle *veh;

		// Create a car
		if(vehicleProb <= proportionCars){
			if(turnProb <= probRightCars)
				veh = new Vehicle(lane, VehicleType::car, true);
			else
				veh = new Vehicle(lane, VehicleType::car, false);
		}

		// Create a SUV
		else if(vehicleProb <= proportionCars + proportionSUVs){
			if(turnProb <= probRightSUVs)
				veh = new Vehicle(lane, VehicleType::suv, true);
			else
				veh = new Vehicle(lane, VehicleType::suv, false);
		}

		// Create a truck
		else{
			if(turnProb <= probRightCars)
				veh = new Vehicle(lane, VehicleType::truck, true);
			else
				veh = new Vehicle(lane, VehicleType::truck, false);
		}

		// Push created vehicle into vehicleVector
		vehicleVector.push_back(veh);
	}
}

/**
 * Move traffic exactly by one section
 */
void Simulation::step(){

	// Find indices of vehicles needed to be deallocated
	// It is needed if two consecutives vehicles will be deleted
	vector<int> indices;
	for (size_t i = 0; i < vehicleVector.size(); i++){
        if (vehicleVector[i]->reachedEnd())
			indices.push_back(i);
    }

	// Deallocate vehicles at correct indices
	for(size_t i = 0; i < indices.size(); i++){
		int index = indices[i] - i;
		// Create a pointer to a vehicle because deletes vector's memory otherwise
        Vehicle* vehiclePtr = vehicleVector[index];
        vehicleVector.erase(vehicleVector.begin() + index);
        delete vehiclePtr;
	}

	// Move every vehicle in the system
	for (size_t i = 0; i < vehicleVector.size(); i++)
		vehicleVector[i]->move();
}

#endif
